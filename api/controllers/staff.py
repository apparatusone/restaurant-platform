from sqlalchemy.orm import Session
from fastapi import HTTPException, status, Response
from ..models import staff as model
from sqlalchemy.exc import SQLAlchemyError
import logging
from ..schemas.staff import StaffCreate, StaffUpdate
from ..security.hashing import hash_pin

logger = logging.getLogger(__name__)

def create(db: Session, request: StaffCreate):
    # NOTE: staff_id is auto-generated by default_factory in the schema if not provided
    hashed = hash_pin(request.pin) # hash the user's pin
    new_staff = model.Staff(
        staff_id=request.staff_id,
        name=request.name,
        role=request.role,
        is_active=request.is_active,
        pin_hash=hashed,
        failed_attempts=request.failed_attempts,
        last_login=request.last_login,
    )

    try:
        db.add(new_staff)
        db.commit()
        db.refresh(new_staff)
    except SQLAlchemyError:
        # log full stack trace server-side; 
        # return a generic message to clients to avoid leaking DB details
        logger.exception("Database error during staff creation")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Database error")

    return new_staff

def read_all(db: Session):
    try:
        result = db.query(model.Staff).all()
    except SQLAlchemyError:
        logger.exception("Database error during staff read_all")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Database error")
    return result


def read_one(db: Session, id: int):
    try:
        item = db.query(model.Staff).filter(model.Staff.id == id).first()
        if not item:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Id not found!")
    except SQLAlchemyError:
        logger.exception("Database error during staff read_one")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Database error")
    return item


def update(db: Session, id: int, request: StaffUpdate):
    try:
        instance = db.query(model.Staff).filter(model.Staff.id == id).first()
        if not instance:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Id not found!")

        update_data = request.dict(exclude_unset=True)

        # do not allow staff_id changes unless explicitly intended;
        # this prevents accidental login-code reassignment
        update_data.pop("staff_id", None)

        for key, value in update_data.items():
            setattr(instance, key, value)

        db.commit()
        db.refresh(instance)
    except SQLAlchemyError:
        logger.exception("Database error during staff update")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Database error")
    return instance


def delete(db: Session, id: int):
    try:
        item = db.query(model.Staff).filter(model.Staff.id == id)
        if not item.first():
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Id not found!")
        item.delete(synchronize_session=False)
        db.commit()
    except SQLAlchemyError:
        logger.exception("Database error during staff delete")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Database error")
    return Response(status_code=status.HTTP_204_NO_CONTENT)